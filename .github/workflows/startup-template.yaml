name: Startup Droplet & Deploy Game

on:
  workflow_call:
    inputs:
      env:
        required: true
        type: string
    secrets:
      DIGITAL_OCEAN_PAT:
        required: true
      DIGITAL_OCEAN_SPACES_ACCESS_KEY_ID:
        required: true
      DIGITAL_OCEAN_SPACES_SECRET_KEY:
        required: true
      DIGITAL_OCEAN_DROPLET_IP:
        required: true
      DIGITAL_OCEAN_DROPLET_SSH_PRIVATE_KEY:
        required: true
      BEASTLYBRAWL_APP_SSL_CERT:
        required: true
      BEASTLYBRAWL_APP_SSL_KEY:
        required: true
      GHCR_PACKAGES_TOKEN:
        required: true
      BEASTLYBRAWL_APP_ROOT_URL:
        required: true

env:
  working_directory: ./terraform
  snapshot_name: bbs-snapshot-latest-${{ inputs.env }}
  droplet_name: droplet-bbs-game-server-${{ inputs.env }}
  droplet_user: root
  ghcr_user: fit3170-beastly-brawl
  image_name: beastly-brawl-${{ inputs.env }}
  registry: ghcr.io

jobs:
  startup:
    name: Startup the droplet (if it is down)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup environment variables
        run: |
          echo "DIGITALOCEAN_ACCESS_TOKEN=${{ secrets.DIGITAL_OCEAN_PAT }}" >> $GITHUB_ENV
          echo "TF_VAR_do_token=${{ secrets.DIGITAL_OCEAN_PAT }}" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=${{ secrets.DIGITAL_OCEAN_SPACES_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.DIGITAL_OCEAN_SPACES_SECRET_KEY }}" >> $GITHUB_ENV

      # doctl is DigitalOcean's command line tool to interact with their API.
      - name: Install doctl
        run: |
          curl -sL https://github.com/digitalocean/doctl/releases/download/v1.135.0/doctl-1.135.0-linux-amd64.tar.gz | tar -xz
          sudo mv doctl /usr/local/bin
          doctl version
          doctl auth init -t ${{ secrets.DIGITAL_OCEAN_PAT }}

      # Check if the droplet is already running.
      - name: Check if droplet is already running
        id: check_droplet
        run: |
          set -e

          DROPLET_ID=$(doctl compute droplet list --format ID,Name,Status --no-header | grep "${{ env.droplet_name }}" | awk '{print $1}')

          if [ -n "$DROPLET_ID" ]; then
            STATUS=$(doctl compute droplet get "$DROPLET_ID" --format Status --no-header)
            if [ "$STATUS" = "active" ]; then
              echo "already_running=true" >> $GITHUB_OUTPUT
            fi
          fi

      # Since we need to recreate the droplet every time we start it up, we create it from the latest snapshot (if it exists).continue-on-error:
      # This basically just swaps out a variable in the terraform code so that instead of creating a new droplet from a base Ubuntu image, it creates it from the latest snapshot.
      - name: Update Terraform image variable to latest snapshot
        if: steps.check_droplet.outputs.already_running != 'true'
        working-directory: ${{ env.working_directory }}
        run: |
          set -e

          # Get the latest snapshot ID 
          SNAPSHOT_ID=$(doctl compute snapshot list --resource droplet --format ID,Name,Created --no-header \
            | grep "${{ env.snapshot_name }}" \
            | sort -rk3 \
            | head -n1 \
            | awk '{print $1}')

          if [ -n "$SNAPSHOT_ID" ]; then
            echo "TF_VAR_droplet_image=$SNAPSHOT_ID" >> $GITHUB_ENV
            echo "Snapshot has been found with ID $SNAPSHOT_ID"
          else
            echo "No snapshot found with name '${{ env.snapshot_name }}'. Not setting TF_VAR_droplet_image."
          fi

      # Terraform will be used to manage the infrastructure. In most cases, this will just create a new droplet from the latest snapshot.
      - name: Setup Terraform
        if: steps.check_droplet.outputs.already_running != 'true'
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        if: steps.check_droplet.outputs.already_running != 'true'
        working-directory: ${{ env.working_directory }}
        run: terraform init -backend-config="key=terraform.${{ inputs.env }}.tfstate"

      - name: Terraform Plan
        if: steps.check_droplet.outputs.already_running != 'true'
        working-directory: ${{ env.working_directory }}
        run: |
          set -e
          terraform plan -var-file="terraform.${{ inputs.env }}.tfvars" -out=startup.tfplan | sed -E 's/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/***.***.***.***/g'

      - name: Terraform Apply
        if: steps.check_droplet.outputs.already_running != 'true'
        working-directory: ${{ env.working_directory }}
        run: |
          set -e
          terraform apply -var-file="terraform.${{ inputs.env }}.tfvars" -auto-approve startup.tfplan 2>&1 | sed -E 's/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/***.***.***.***/g'

  # Builds all the Docker related stuff.
  docker_build:
    name: Build the Docker Image of the Meteor Application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.registry }}
          username: ${{ env.ghcr_user }}
          password: ${{ secrets.GHCR_PACKAGES_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.registry }}/${{ env.ghcr_user }}/${{ env.image_name }}
          tags: |
            type=raw,value=latest,enable=true

      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          file: ./Dockerfile
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          build-args: |
            ENV=${{ inputs.env }}
            ROOT_URL=${{ secrets.BEASTLYBRAWL_APP_ROOT_URL }}

      - name: Delete old package versions
        uses: actions/delete-package-versions@v5
        with:
          owner: ${{ env.ghcr_user }}
          package-name: ${{ env.image_name }}
          package-type: container
          min-versions-to-keep: 10
          delete-only-untagged-versions: true
          token: ${{ secrets.GHCR_PACKAGES_TOKEN }}

  deployment:
    name: Deploy the Meteor application using Docker Compose
    runs-on: ubuntu-latest
    needs:
      - startup
      - docker_build
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.registry }}
          username: ${{ env.ghcr_user }}
          password: ${{ secrets.GHCR_PACKAGES_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.registry }}/${{ env.ghcr_user }}/${{ env.image_name }}
          tags: |
            type=raw,value=latest,enable=true

      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          file: ./deployment/Dockerfile
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          build-args: |
            ENV=${{ inputs.env }}
            ROOT_URL=${{ secrets.BEASTLYBRAWL_APP_ROOT_URL }}

  #     - name: Delete old package versions
  #       uses: actions/delete-package-versions@v5
  #       with:
  #         owner: ${{ env.ghcr_user }}
  #         package-name: ${{ env.image_name }}
  #         package-type: container
  #         min-versions-to-keep: 10
  #         delete-only-untagged-versions: true
  #         token: ${{ secrets.GHCR_PACKAGES_TOKEN }}

  deployment:
    name: Deploy the Meteor application using Docker Compose
    runs-on: ubuntu-latest
    needs:
      - startup
      - docker_build
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # This script is needed to run the docker containers which will host the game application
      - name: Copy setup script to Droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DIGITAL_OCEAN_DROPLET_IP }}
          username: ${{ env.droplet_user }}
          key: ${{ secrets.DIGITAL_OCEAN_DROPLET_SSH_PRIVATE_KEY }}
          source: "./deployment/setup.sh"
          target: "~/deployment"
          strip_components: 2

      # Docker compose will be used to run the application. This allows us to run multiple services at once easily.
      # In theory we probably just need to run two services, nginx and the Meteor app
      - name: Copy docker compose script to Droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DIGITAL_OCEAN_DROPLET_IP }}
          username: ${{ env.droplet_user }}
          key: ${{ secrets.DIGITAL_OCEAN_DROPLET_SSH_PRIVATE_KEY }}
          source: "./deployment/docker-compose.yaml"
          target: "~/deployment"
          strip_components: 2

      # Renames the nginx configuration file to just default.conf
      - name: Prepare nginx config file
        run: cp ./deployment/default.${{ inputs.env }}.conf ./deployment/default.conf

      # This is the nginx configuration file which will be used to serve the Meteor app to a web server. This is needed to handle SSL and reverse proxying.
      - name: Copy nginx config file to Droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DIGITAL_OCEAN_DROPLET_IP }}
          username: ${{ env.droplet_user }}
          key: ${{ secrets.DIGITAL_OCEAN_DROPLET_SSH_PRIVATE_KEY }}
          source: "./deployment/default.conf"
          target: "~/deployment"
          strip_components: 2

      # Create the ssl.crt and ssl.key files from the secrets. These will be used by nginx to serve the app over HTTPS.
      - name: Create SSL cert and key files
        run: |
          echo '${{ secrets.BEASTLYBRAWL_APP_SSL_CERT }}' > ./ssl.crt
          echo '${{ secrets.BEASTLYBRAWL_APP_SSL_KEY }}' > ./ssl.key

      - name: Copy ssl cert to Droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DIGITAL_OCEAN_DROPLET_IP }}
          username: ${{ env.droplet_user }}
          key: ${{ secrets.DIGITAL_OCEAN_DROPLET_SSH_PRIVATE_KEY }}
          source: "./ssl.crt"
          target: "~/deployment"

      - name: Copy ssl key to Droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DIGITAL_OCEAN_DROPLET_IP }}
          username: ${{ env.droplet_user }}
          key: ${{ secrets.DIGITAL_OCEAN_DROPLET_SSH_PRIVATE_KEY }}
          source: "./ssl.key"
          target: "~/deployment"

      # This will pull the docker images needed and run the containers on the droplet using Docker Compose.
      - name: Run the setup script on Droplet
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DIGITAL_OCEAN_DROPLET_IP }}
          username: ${{ env.droplet_user }}
          key: ${{ secrets.DIGITAL_OCEAN_DROPLET_SSH_PRIVATE_KEY }}
          script: |
            source ~/deployment/setup.sh ${{ secrets.GHCR_PACKAGES_TOKEN }} ${{ inputs.env }}
